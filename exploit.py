import subprocess, sys, time, collections, json, csv, os, pathlib

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def find_wifi(interface):
    timeout = 10
    start_time = time.time()
    pathlib.Path(os.path.join(os.getcwd(), 'captures')).mkdir(exist_ok=True)
    airodump = subprocess.Popen(['sudo','airodump-ng', '-o', 'csv', '-w', os.path.join(os.getcwd(), "captures", ".out"), interface], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    table = collections.defaultdict(lambda: collections.defaultdict(str))
    while time.time() < start_time + timeout:
        continue
    airodump.terminate()
    has_labels = False
    end_of_search = False
    BSSID_index = -1
    ESSID_index = -1
    Privacy_index = -1
    channel_index = -1
    for (_, line) in  enumerate(csv.reader(open(os.path.join(os.getcwd(), "captures", '.out-01.csv'), 'r'), quotechar='"', delimiter=',', quoting=csv.QUOTE_ALL, skipinitialspace=True)):
        line = list(filter(None, line))
        if len(line) == 0:
            continue
        if not has_labels:
            has_labels = True
            array = [idx for idx, s in enumerate(line) if 'BSSID' in s]
            if len(array) != 0:
                BSSID_index = array[0]
            array = [idx for idx, s in enumerate(line) if 'ESSID' in s]
            if len(array) != 0:
                ESSID_index = array[0]
            array = [idx for idx, s in enumerate(line) if 'Privacy' in s]
            if len(array) != 0:
                Privacy_index = array[0]
            array = [idx for idx, s in enumerate(line) if 'channel' in s]
            if len(array) != 0:
                channel_index = array[0]
        elif not end_of_search:
            array = [idx for idx, s in enumerate(line) if 'Station MAC' in s]
            if len(array) != 0:
                end_of_search = True
                continue
            if len(line) > ESSID_index and len(line) > Privacy_index:
                table[line[ESSID_index]]["BSSID"] = line[BSSID_index]
                table[line[ESSID_index]]["ESSID"] = line[ESSID_index]
                table[line[ESSID_index]]["Privacy"] = line[Privacy_index]
                table[line[ESSID_index]]["Channel"] = line[channel_index]
    os.remove(os.path.join(os.getcwd(), "captures", '.out-01.csv'))
    return table

def get_interface():
    result = subprocess.check_output(['sudo', 'airmon-ng']).decode("utf-8").split('\n')
    result = list(filter(None, result))
    labels = result[0].split()
    index = labels.index("Interface")
    return result[1].split()[index]

def exploit(network):
    sys.stdout.flush()
    sys.stdout.write(bcolors.OKBLUE + "Checking Dependencies \r" + bcolors.ENDC)
    sys.stdout.flush()
    result = subprocess.run(['which', 'aircrack-ng'], capture_output=True, text=True).stdout
    if not result:
        print("Install aircrack-ng first")
        print("sudo apt-get install aircrack-ng")
        return
    sys.stdout.write(bcolors.OKBLUE + "Getting network interfaces \r" + bcolors.ENDC)
    sys.stdout.flush()
    interface = get_interface()
    #subprocess.call(['sudo', 'airmon-ng', 'check', 'kill'], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    sys.stdout.write(bcolors.OKBLUE + "Enabling Monitor Mode \r" + bcolors.ENDC)
    sys.stdout.flush()
    subprocess.call(['sudo', 'airmon-ng', 'stop', interface + "mon"], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    subprocess.call(['sudo', 'airmon-ng', 'start', interface], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    sys.stdout.write(bcolors.OKBLUE + "Scanning For Network \r" + bcolors.ENDC)
    sys.stdout.flush()
    network_database = find_wifi(interface + "mon")
    result = network_database[network]
    time.sleep(1)
    subprocess.call(['sudo', 'airmon-ng', 'stop', interface + "mon"], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    sys.stdout.write(bcolors.OKBLUE + "Disabling Monitor Mode \r" + bcolors.ENDC)
    sys.stdout.flush()
    sys.stdout.write("\n")
    sys.stdout.write(json.dumps(result) + '\n')

if __name__ == "__main__":
    if len(sys.argv) != 2:
        exit(1)
    else:
        exploit(sys.argv[1])
